using CairoDesktop.Common;
using System;
using System.Collections;
using System.Linq;

namespace CairoDesktop.Extensibility.Plugins
{
    /// <summary>
    /// Provides a strongly-typed collection of PluginDescriptor instances.
    /// This class is thread safe.
    /// </summary>
    //	[System.Diagnostics.DebuggerStepThrough()]
    public sealed class PluginDescriptorCollection : DisposableCollection
    {
        #region PluginDescriptorAlreadyExistsException

        /// <summary>
        /// Defines an Exception that is generated by the PluginDescriptorCollection when a PluginDescriptor
        /// is added to the collection for a Type when another PluginDescriptor already exists in the collection for the same Type.
        /// </summary>
        public sealed class PluginDescriptorAlreadyExistsException : ApplicationException
        {
            private readonly PluginDescriptor _descriptor;

            internal PluginDescriptorAlreadyExistsException(PluginDescriptor descriptor) :
                base(string.Format("The PluginDescriptor '{0}' already exists in the collection.", descriptor))
            {
                _descriptor = descriptor;
            }

            public PluginDescriptor PluginDescriptor
            {
                get { return _descriptor; }
            }
        }

        #endregion

        #region LeastDependentComparer

        /// <summary>
        /// Defines an IComparer implementation that sorts PluginDescriptor instances,
        /// placing the least dependent descriptors first in the collection.
        /// </summary>
        private sealed class LeastDependentComparer : IComparer
        {
            #region IComparer Members

            /// <summary>
            /// Compares two PluginDescriptor instances.
            /// </summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <returns></returns>
            public int Compare(object x, object y)
            {
                var xDescriptor = (PluginDescriptor)x;
                var yDescriptor = (PluginDescriptor)y;

                //Log.WriteLine(xDescriptor.ToString() + " == " + yDescriptor.ToString());

                if (xDescriptor == yDescriptor)
                    return 0;

                // the opposite of the MostDependentComparer class
                bool xDependsOnY = xDescriptor.DependsOn(yDescriptor);
                bool yDependsOnX = yDescriptor.DependsOn(xDescriptor);

                if (xDependsOnY)
                    return 1;

                if (yDependsOnX)
                    return -1;

                return 0;
            }

            #endregion
        }

        #endregion

        #region MostDependentComparer

        /// <summary>
        /// Defines an IComparer implementation that sorts PluginDescriptor instances,
        /// placing the most dependent descriptors first in the collection.
        /// </summary>
        private sealed class MostDependentComparer : IComparer
        {
            #region IComparer Members

            /// <summary>
            /// Compares two PluginDescriptor instances.
            /// </summary>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <returns></returns>
            public int Compare(object x, object y)
            {
                var xDescriptor = (PluginDescriptor)x;
                var yDescriptor = (PluginDescriptor)y;

                if (xDescriptor == yDescriptor)
                    return 0;

                // the opposite of the LeastDependentComparer class
                bool xDependsOnY = xDescriptor.DependsOn(yDescriptor);
                bool yDependsOnX = yDescriptor.DependsOn(xDescriptor);

                if (xDependsOnY)
                    return -1;

                if (yDependsOnX)
                    return 1;

                return 0;
            }

            #endregion
        }

        #endregion

        /// <summary>
        /// Initializes a new instance of the PluginDescriptorCollection class
        /// </summary>
        internal PluginDescriptorCollection()
        {
        }

        /// <summary>
        /// Returns the PluginDescriptor from the collection that contains the Type specified.
        /// </summary>
        public PluginDescriptor this[Type pluginType]
        {
            get
            {
                lock (SyncRoot)
                {
                    return InnerList.Cast<PluginDescriptor>().FirstOrDefault(descriptor => descriptor.PluginType == pluginType);
                }
            }
        }

        /// <summary>
        /// Returns the PluginDescriptor from the collection that contains the Type specified.
        /// </summary>
        /// <param name="pluginTypeFullName">The full Type name of the Type to look for</param>
        public PluginDescriptor this[string pluginTypeFullName]
        {
            get
            {
                lock (SyncRoot)
                {
                    return InnerList.Cast<PluginDescriptor>().FirstOrDefault(descriptor => string.Compare(descriptor.PluginType.FullName, pluginTypeFullName, true) == 0);
                }
            }
        }

        /// <summary>
        /// Adds a PluginDescriptor to the collection.
        /// </summary>
        /// <param name="descriptor">The descriptor to add to the collection</param>
        internal void Add(PluginDescriptor descriptor)
        {
            if (Contains(descriptor))
                throw new PluginDescriptorAlreadyExistsException(descriptor);

            lock (SyncRoot)
            {
                InnerList.Add(descriptor);
            }
        }

        /// <summary>
        /// Adds an array of plugin descriptors to the collection.
        /// </summary>
        /// <param name="descriptors">The array of descriptors to add.</param>
        internal void Add(PluginDescriptor[] descriptors)
        {
            if (descriptors == null)
                throw new ArgumentNullException("descriptors");

            foreach (PluginDescriptor descriptor in descriptors)
            {
                Add(descriptor);
            }
        }

        /// <summary>
        /// Determines if the collection contains a PluginDescriptor to the same Type as the one specified.
        /// </summary>
        /// <param name="descriptor">The PluginDescriptor to check for</param>
        /// <returns></returns>
        public bool Contains(PluginDescriptor descriptor)
        {
            if (descriptor == null)
                throw new ArgumentNullException("descriptor");
            return (this[descriptor.PluginType] != null);
        }

        /// <summary>
        /// Sorts the collection of descriptors.
        /// </summary>
        /// <param name="leastDependentFirst">A flag that if true sorts the collection placing descriptors with the least
        /// number of dependencies first, false places the descriptors with the most dependencies first.</param>
        public void Sort(bool leastDependentFirst)
        {
            // use our custom comparers to sort based on dependencies
            IComparer comparer;

            if (leastDependentFirst)
                comparer = new LeastDependentComparer();
            else
                comparer = new MostDependentComparer();

            Sort(comparer);
        }

        internal new void Clear()
        {
            lock (SyncRoot)
            {
                InnerList.Clear();
            }
        }

        /// <summary>
        /// Returns the contents of the collection as a PluginDescriptor array.
        /// </summary>
        /// <returns></returns>
        internal PluginDescriptor[] ToArray()
        {
            lock (SyncRoot)
            {
                return InnerList.ToArray(typeof(PluginDescriptor)) as PluginDescriptor[];
            }
        }
    }
}